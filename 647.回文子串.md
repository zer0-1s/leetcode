```C
/*两层for循环，遍历区间起始位置和终止位置，然后判断这个区间是不是回文,时间复杂度：O(n^3)*/
int reverseTojudge(char *s,int begin,int end){
        // 正逆序结合
        int count = 0 ;
        int mid = (end - begin + 1)/2; 
    	// 正序和逆序同时比对
        while(begin < end)
            if(s[begin++]==s[end--])
                count++;
            else
                break; 
    	// 判断条件不能使用begin，end这种同时变化的变量 
        if(count == mid ||  mid == 0)
        return 1;
        else
        return 0;
}
int countSubstrings(char * s){
    int temp = 0;
    for(int i = 0;i < strlen(s);i++)
        for(int j = i;j < strlen(s);j++)
        {
            if(s[i] == s[j])
                if(reverseTojudge(s,i,j))
                    temp++;

        }
        return temp;
}

```
> 调试代码参考

```C
#include"stdio.h"  /*printf*/
#include"string.h" /*strlen*/
int reverseTojudge(char *s,int begin,int end){
        // 正逆序结合
        int count = 0 ;
        int mid = (end - begin + 1)/2; 
        while(begin < end)
            if(s[begin++]==s[end--])
                count++;
            else
                break; 
            
        if(count == mid || mid == 0)
        return 1;
        else
        return 0;
}
void showSubstring(char *s,int begin,int end){
    
    for(int i = begin;i < end+1;i++)
        printf("%c",s[i]);
    printf("\n");
}
int countSubstrings(char * s){
    int temp = 0;
    for(int i = 0;i < strlen(s);i++)
        for(int j = i;j < strlen(s);j++)
        {
            if(s[i] == s[j])
                if(reverseTojudge(s,i,j))
                    {showSubstring(s,i,j);
                    temp++;
                    }
        }
        return temp;
}

int main(){
    char *s = "longtimenosee";
    int count = countSubstrings(s);
    printf("%d",count);
}
```

> 动态规划解法
```C
/*时间复杂度：O(n^2),空间复杂度：O(n^2),时间复杂度是嵌套两层for循环,空间复杂度是dp表*/
int countSubstrings(char * s){
    // dp 初始化为flase
    int length =  strlen(s);
    bool dp[length][length];
    memset(dp, 0, length*length*sizeof(bool));
    int temp = 0;
    // 从左下到右上
    for(int i = strlen(s)-1;i >= 0;i--)
        for(int j = i;j < strlen(s);j++)
        {
            if(s[i] == s[j])
                {
                    if (j - i <= 1) { // 情况一 和 情况二
                    temp++;
                    dp[i][j] = 1;

                    }
                    else if(dp[i+1][j-1])
                    {
                        temp++;
                        dp[i][j] = 1;

                    }
                }
        }
        return temp;
}
```

<p>
参考：代码随想录
情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
情况二：下标i 与 j相差为1，例如aa，也是文子串
情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。
</p>

![image](https://user-images.githubusercontent.com/62493040/151121475-e633779f-8464-493a-ba42-8330f5fe6695.png)

