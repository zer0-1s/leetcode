> 方法一：暴力搜索
``` C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    *returnSize = 0;
    int size;
    if(nums1Size >= nums2Size)
        size = nums1Size;
    else
        size = nums2Size;
    int * ret = (int*)malloc(sizeof(int)*size);
    for(int i = 0;i < nums1Size;i++)
        for(int j = 0;j < nums2Size;j++)
            {
            int flag = 1;
            for(int k = 0;k < (*returnSize);k++)
                if(ret[k] == nums1[i])
                    {
                    flag = 0;
                    break;
                    }
            if(nums1[i] == nums2[j]&&flag)
            {                   

                 ret[(*returnSize)++] = nums1[i];

                

                }
            }   
    return ret;
                
}
```
> 方法二：双指针+排序

```` C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

int compare (const void * a,const  void * b)
{
 return ( *(int*)a - *(int*)b );
}

int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    // 升序
    qsort(nums1,nums1Size,sizeof(int),compare);
    qsort(nums2,nums2Size,sizeof(int),compare);
    // 双指针
    int index1 = 0 ,index2 = 0;
    // 分配空间
    int length = (nums1Size >= nums2Size) ? nums2Size : nums1Size; 
    int *ret = (int*)malloc(sizeof(int)*length);
    *returnSize = 0;
    while(index1 < nums1Size && index2 < nums2Size )
      
        {  int num1 = nums1[index1],num2 =  nums2[index2];
            if(num1!=num2)
            num1> num2 ? index2++ : index1++;
            if(num1 == num2)
            {   // 针对排序后的连续相等
                if((*returnSize) == 0 || ret[(*returnSize)-1] != num1 )
                    ret[(*returnSize)++] = num1;
                index1++;
                index2++;
            }					
         }
        return ret;
    
}

```

> 本地测试代码
``` C

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
#include"stdio.h"
#include"stdlib.h"

int compare (const void * a,const  void * b)
{
 return ( *(int*)a - *(int*)b );
}

int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    // 升序
    qsort(nums1,nums1Size,sizeof(int),compare);
    qsort(nums2,nums2Size,sizeof(int),compare);
    // 双指针
    int index1 = 0 ,index2 = 0;
    //Show(nums1,nums1Size);
    //Show(nums2,nums2Size);
    // 分配空间
    int length = (nums1Size >= nums2Size) ? nums2Size : nums1Size; 
    int *ret = (int*)malloc(sizeof(int)*length);
    *returnSize = 0;
    while(index1 < nums1Size && index2 < nums2Size )
      
        {  int num1 = nums1[index1],num2 =  nums2[index2];
            if(num1!=num2)
            num1> num2 ? index2++ : index1++;
            if(num1 == num2)
            {   // 针对排序后的连续相等
                if((*returnSize) == 0 || ret[(*returnSize)-1] != num1 )
                    ret[(*returnSize)++] = num1;
                index1++;
                index2++;
            }					
         }
      
        return ret;
    
}
void Show(int* s,int length )
{
    for(int i = 0;i < length;i++)
        printf("%d ",s[i]);
}

void main()
{
    int s1[2] = {1,2};
    int s2[2] = {2,1};
    int num = 0 ;
    int *ret = intersection(s1,2, s2, 2,&num);
    Show(ret,num);


}

```
