> 方法一：暴力搜索
``` C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    *returnSize = 0;
    int size;
    if(nums1Size >= nums2Size)
        size = nums1Size;
    else
        size = nums2Size;
    int * ret = (int*)malloc(sizeof(int)*size);
    for(int i = 0;i < nums1Size;i++)
        for(int j = 0;j < nums2Size;j++)
            {
            int flag = 1;
            for(int k = 0;k < (*returnSize);k++)
                if(ret[k] == nums1[i])
                    {
                    flag = 0;
                    break;
                    }
            if(nums1[i] == nums2[j]&&flag)
            {                   

                 ret[(*returnSize)++] = nums1[i];

                

                }
            }   
    return ret;
                
}
```

> 方法二：双指针+排序

```` C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

int compare (const void * a,const  void * b)
{
 return ( *(int*)a - *(int*)b );
}

int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){
    // 升序
    qsort(nums1,nums1Size,sizeof(int),compare);
    qsort(nums2,nums2Size,sizeof(int),compare);
    // 双指针
    int index1 = 0 ,index2 = 0;
    // 分配空间
    int length = (nums1Size >= nums2Size) ? nums2Size : nums1Size; 
    int *ret = (int*)malloc(sizeof(int)*length);
    *returnSize = 0;
    while(index1 < nums1Size && index2 < nums2Size )
      
        {  int num1 = nums1[index1],num2 =  nums2[index2];
            if(num1!=num2)
            num1> num2 ? index2++ : index1++;
            if(num1 == num2)
            {   // 针对排序后的连续相等
                if((*returnSize) == 0 || ret[(*returnSize)-1] != num1 )
                    ret[(*returnSize)++] = num1;
                index1++;
                index2++;
            }					
         }
        return ret;
    
}
````

> 方法三：hash表

## uthash

  由于C语言本身不存在哈希，但是当需要使用哈希表的时候自己构建哈希会异常复杂。因此，可以调用第三方开源头文件，**这只是一个头文件**：uthash.h。我们需要做的就是将头文件复制到您的项目中，然后：#include “uthash.h”。由于uthash仅是头文件，因此没有可链接的库代码。使用uthash添加，查找和删除通常是常数时间的操作，此哈希的目标是简约高效。它大约有1000行C。它会自动内联，因为它是作为宏实现的。

​		此外uthash还包括三个额外的头文件，主要提供链表，动态数组和字符串。utlist.h为C结构提供了链接列表宏。utarray.h使用宏实现动态数组。utstring.h实现基本的动态字符串。

  github下载链接：https://github.com/troydhanson/uthash

